#pragma config(Sensor, S3,     Colour,         sensorEV3_Color, modeEV3Color_Ambient)
#pragma config(Motor,  motorB,          LeftMotor,     tmotorEV3_Large, PIDControl, reversed, driveLeft, encoder)
#pragma config(Motor,  motorC,          TiltMotor,     tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorD,          RightMotor,    tmotorEV3_Large, PIDControl, reversed, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int threshold = 10;
int maxValue = 20;
int minValue = 0;
int tMaxValue = threshold;
int tMinValue = threshold;
int calibInterval = 4000;

const int cmdSpace = 2000;
const int shortLongBorder = 600;

const int morseTable[6][6] =
{
	{0,1,0,0,0,0}, 	// a 0
	{1,0,0,0,0,0},  // b 1
	{1,0,1,0,0,0},	// c 2
	{0,0,0,0,0,0},	// e 3
	{0,0,1,0,0,0},	// f 4
	{1,1,0,0,0,0},	// g 5
};

bool buffer[6];
int added = 0;

void newCmd()
{
	int cmd = -1;
	for (int c = 0; c<6; c++)
	{
		int s;
		for (s = 0; s<sizeof(buffer); s++)
		{
			if (buffer[s] != morseTable[c][s]) break;
		}
		if (s==sizeof(buffer)
			{
				cmd = c;
				break;
			}
	}
	char str[15];
	sprintf(str, "%d %d %d %d %d %d", buffer[0],buffer[1],buffer[2],buffer[3],buffer[4],buffer[5] );
	displayString(10, str);
	sprintf(str, "%d %d %d %d %d %d", morseTable[4][0],morseTable[4][1],morseTable[4][2],morseTable[4][3],morseTable[4][4],morseTable[4][5] );
	displayString(11, str);

	sprintf(str,"%d",cmd);
	displayString(14, str);

	sprintf(str,"%d",sizeof(buffer));
	displayString(12,str);

	memset(&buffer[0], 0, sizeof(buffer));
	added = 0;

	switch (cmd) {
		case 0: moveMotorTarget(RightMotor,1000,100); moveMotorTarget(LeftMotor,1000,100);  break; // Forward
		case 1: moveMotorTarget(RightMotor,1000,-100); moveMotorTarget(LeftMotor,1000,-100);  break; // Backwards
		case 2: moveMotorTarget(RightMotor,360,100); moveMotorTarget(LeftMotor,360,-100);  break; // Left
		case 3: moveMotorTarget(RightMotor,360,-100); moveMotorTarget(LeftMotor,360,100);  break; // Right

	}
	displayString(13, "newCMD");
}

void addSignal(bool isLong)
{

	displayString(13, isLong?"Long":"Short");
	buffer[added++] = isLong;
}

task main()
{
	bool pre = false;
	bool now = pre;
	while (true)
	{
		int v = SensorValue[Colour];
		char str[15];
		sprintf(str, "%d", v);
		displayString(6,str);


		now = v>threshold;
		if (now!=pre) // detect edge
		{
			int speed = now?66:0;
			setLEDColor(now?ledGreen:ledOff);
			//setMotorSpeed(leftMotor,speed);
			//setMotorSpeed(rightMotor,speed);

			if (v > tMaxValue) tMaxValue = v;
			if (v < tMinValue) tMinValue = v;

			sprintf(str, "%d", maxValue);
			displayString(7,str);
			sprintf(str, "%d", minValue);
			displayString(8,str);

			if (pre) // falling edge
			{
				int sinceLast = time1[T2];
				clearTimer(T2);
				sprintf(str, "%d", sinceLast);
				//displayString(13,str);
				if (sinceLast>cmdSpace) {
					newCmd();
				} else if(added==6-1){
					// clear buffer
					memset(&buffer[0], 0, sizeof(buffer));
					added = 0;
				} else {
					addSignal( sinceLast>shortLongBorder );
				}
			}
		}

		if (time1[T1] > calibInterval)
		{
			clearTimer(T1);
			maxValue = tMaxValue;
			minValue = tMinValue;
			threshold = (tMaxValue+tMinValue)/2;
			tMaxValue = tMinValue = 10;
		}

		pre = now;
		sleep(1);
	}
}
